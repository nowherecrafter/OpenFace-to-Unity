using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using Palmmedia.ReportGenerator.Core.CodeAnalysis;
using Unity.VisualScripting;
using UnityEditor.Profiling;
using UnityEngine;
using UnityEngine.Video;
using static TMPro.SpriteAssetUtilities.TexturePacker_JsonArray;
using static UnityEditor.Experimental.GraphView.GraphView;



public class AppManager : MonoBehaviour
{
    int bsIndex;



    public VideoPlayer player;
    public KeyCode playKey = KeyCode.Space;
    public KeyCode skipFrameKey = KeyCode.LeftControl;

    // A .csv file generated by OpenFace. Should include AUs ONLY!!!
    public TextAsset actionUnitData;

    // Game Objects manipulated by the script
    public Transform Camera;
    public SkinnedMeshRenderer[] smRenderers;
    public Transform headBone;

    public int testFrame;

    public AnimParam parameters;

    [SerializeField]BlendshapeAnimator blendshapeAnimator;


    float time = 0f;
    bool play = false;
    float frameTime;

    int frameIndex = 0;

    // A list of structures containing data frame by frame
    List<Frame> frames = new List<Frame>();

    public Transform GetCamera() { return Camera; }

    public SkinnedMeshRenderer[] GetSMRenderers() { return smRenderers; }

    public Transform GetHeadBone() { return headBone; }

    public Frame getFirstFrame() { return frames[0]; }

    public static AppManager Instance { get; private set; }

    private AudioSource voice;
    private void Awake()
    {
        // If there is an instance, and it's not me, delete myself.

        if (Instance != null && Instance != this)
        {
            Destroy(this);
        }
        else
        {
            Instance = this;
        }
    }

    
    // Start is called before the first frame update
    void Start()
    {
        frames = CsvImporter.ParseCSV(actionUnitData);
        Debug.Log("anim frames " + frames.Count + " | video frames " + player.frameCount);

        voice = GetComponent<AudioSource>();
    }

    // Update is called once per frame
    void Update()
    {
        //Debug.Log("anim frame " + frameIndex + " | video frame " + player.frame);
        //Debug.Log("anim time " + time + " | video time " + player.time);



        // Check if the assigned key is pressed
        if (Input.GetKeyDown(playKey))
        {
            // Check if the VideoPlayer component is attributed
            if (player != null)
            {
                // Prepare and play the video assigned to the VideoPlayer component only then play the avatar's animation
                player.Prepare();
                if (player.isPrepared)
                {

                    player.Play();

                    play = true;

                    voice.Play();
                }
                    
            }
            else
            {
                //if there's no VideoPlayer assigned, the animation is good on its own
                play = true;

                voice.Play();
            }

            
        }
        


        if (play)
        {
            if (player != null) 
            {
                
                if ((int)player.frame > -1)
                {
                    if ((int)player.frame < frames.Count -1)
                    {
                        // calculating the time passed on the current frame
                        frameTime = (time - frames[(int)player.frame].timestamp) / (frames[(int)player.frame + 1].timestamp - frames[(int)player.frame].timestamp);

                        // setting expression between the current frame and the one that follows
                        blendshapeAnimator.SetFExpression(frames[(int)player.frame], frames[(int)player.frame + 1], frameTime);

                        // set back animation time if VideoPlayer lags behind
                        if (time > player.time + 0.04 || time < player.time)
                            time = frames[(int)player.frame].timestamp;

                    }
                    else if ((int)player.frame == frames.Count - 1)
                    {
                        // calculating the time passed on the current frame
                        frameTime = (time - frames[(int)player.frame].timestamp) / (frames[(int)player.frame].timestamp - frames[(int)player.frame - 1].timestamp);

                        // instead of 2 different frames we prolong the final one
                        blendshapeAnimator.SetFExpression(frames[(int)player.frame], frames[(int)player.frame], frameTime);

                        // reset values after the video ends
                        play = false;
                        
                        time = 0f;
                    }
                

                    
                }

            }
            else
            {

                if (frameIndex < frames.Count - 1)
                {
                    // calculating the time passed between frames
                    frameTime = (time - frames[frameIndex].timestamp) / (frames[frameIndex + 1].timestamp - frames[frameIndex].timestamp);

                    // setting expression between the current frame and the one that follows
                    blendshapeAnimator.SetFExpression(frames[frameIndex], frames[frameIndex + 1], frameTime);


                }
                // case for the last frame
                else if (frameIndex == frames.Count - 1)
                {
                    // calculating the time passed between frames
                    frameTime = (time - frames[frameIndex].timestamp) / (frames[frameIndex].timestamp - frames[frameIndex - 1].timestamp);

                    // instead of 2 different frames we prolong the final one
                    blendshapeAnimator.SetFExpression(frames[frameIndex], frames[frameIndex], frameTime);

                    // reset values after the video ends
                    play = false;
                    frameIndex = 0;
                    time = 0f;
                }

                if (time > frames[frameIndex].timestamp)
                {
                    

                    frameIndex++;
                }



            }

            // time is unstoppable
            time += Time.deltaTime;

            //bsIndex = smRenderers[1].sharedMesh.GetBlendShapeIndex("Mouth_Smile_L");
            //Debug.Log("frame " + frames[frameIndex].frame + " | time " + time + " | timestamp " + frames[frameIndex].timestamp + " | AU " + frames[frameIndex].AU12_r + " | BS " + smRenderers[1].GetBlendShapeWeight(bsIndex));



        }
    }


}
