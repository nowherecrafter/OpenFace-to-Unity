using System.Collections.Generic;
using CrazyMinnow.SALSA;
using UnityEngine;
using UnityEngine.Video;




public class AppManager : MonoBehaviour
{

    FeedbackList feedbackListItems;

    // Video player and controls
    public VideoPlayer player;
    public KeyCode playKey = KeyCode.Space;
    public KeyCode skipFrameKey = KeyCode.LeftControl;

    // A .csv file generated by OpenFace. Should include AUs ONLY!!!
    public TextAsset actionUnitData;

    // Game Objects manipulated by the script
    public Transform Camera;
    public Transform activeAvatar;
    Transform headBone;
    SkinnedMeshRenderer[] smRenderers = new SkinnedMeshRenderer[3];
    AudioSource voice;
    // Eyes object in SALSA
    Eyes eyes;

    

    public AnimParam parameters;

    List<FeedbackElement> items;

    [SerializeField]BlendshapeAnimator blendshapeAnimator;

    // Videoplayer related variables
    float time = 0f;
    bool play = false;
    float frameTime;
    int frameIndex = 0;

    // A list of structures containing data frame by frame
    List<Frame> frames = new List<Frame>();
    public FeedbackElement GetFeedback()
    {
        return items[frameIndex];
    }

    public void SetEyeAnimsEnabled(bool status)
    {
        eyes.EnableEyelidBlink(status);
        eyes.EnableEye(status);
    }

    public bool GetEyeAnimsEnabled()
    {
        return eyes.blinkEnabled || eyes.eyeEnabled; // true if any is enabled
    }

    public Transform GetCamera() { return Camera; }

    public SkinnedMeshRenderer[] GetSMRenderers() { return smRenderers; }

    public Transform GetHeadBone() { return headBone; }

    public Frame getFirstFrame() { return frames[0]; }

    public FeedbackList GetFeedbackList() { return feedbackListItems; }

    public static AppManager Instance { get; private set; }

    private void Awake()
    {
        // If there is an instance, and it's not me, delete myself.

        if (Instance != null && Instance != this)
        {
            Destroy(this);
        }
        else
        {
            Instance = this;
        }

        feedbackListItems = JsonImporter.ParseJSON();
    }

    
    // Start is called before the first frame update
    void Start()
    {
        headBone = activeAvatar.GetChild(2).GetChild(0).GetChild(0).GetChild(0).GetChild(0).GetChild(4).GetChild(0);

        smRenderers[0] = activeAvatar.GetChild(0).Find("Brows").GetComponent<SkinnedMeshRenderer>();
        smRenderers[1] = activeAvatar.GetChild(0).Find("CC_Base_Body").GetComponent<SkinnedMeshRenderer>();
        smRenderers[2] = activeAvatar.GetChild(0).Find("Brows_Extracted0").GetComponent<SkinnedMeshRenderer>();

        voice = GetComponent<AudioSource>();

        eyes = activeAvatar.GetComponent<Eyes>();

        frames = CsvImporter.ParseCSV(actionUnitData);

        //player.Play();
    }

    // Update is called once per frame
    void Update()
    {
        // Check if the assigned key is pressed
        if (Input.GetKeyDown(playKey))
        {
            // Check if the VideoPlayer component is attributed
            if (player != null)
            {
                // Prepare and play the video assigned to the VideoPlayer component only then play the avatar's animation
                player.Prepare();
                if (player.isPrepared)
                {

                    player.Play();

                    play = true;

                    voice.Play();
                }
                    
            }
            else
            {
                //if there's no VideoPlayer assigned, the animation is good on its own
                play = true;

                voice.Play();
            }

            
        }
        


        if (play)
        {
            if (player != null) 
            {
                
                if ((int)player.frame > -1)
                {
                    if ((int)player.frame < frames.Count -1)
                    {
                        // calculating the time passed on the current frame
                        frameTime = (time - frames[(int)player.frame].timestamp) / (frames[(int)player.frame + 1].timestamp - frames[(int)player.frame].timestamp);

                        // setting expression between the current frame and the one that follows
                        blendshapeAnimator.SetFExpression(frames[(int)player.frame], frames[(int)player.frame + 1], frameTime);

                        // set back animation time if VideoPlayer lags behind
                        if (time > player.time + 0.04 || time < player.time)
                            time = frames[(int)player.frame].timestamp;

                    }
                    else if ((int)player.frame == frames.Count - 1)
                    {
                        // calculating the time passed on the current frame
                        frameTime = (time - frames[(int)player.frame].timestamp) / (frames[(int)player.frame].timestamp - frames[(int)player.frame - 1].timestamp);

                        // instead of 2 different frames we prolong the final one
                        blendshapeAnimator.SetFExpression(frames[(int)player.frame], frames[(int)player.frame], frameTime);

                        // reset values after the video ends
                        play = false;
                        Instance.SetEyeAnimsEnabled(true);
                        time = 0f;
                    }
                    
                }

            }
            else
            {

                if (frameIndex < frames.Count - 1)
                {
                    // calculating the time passed between frames
                    frameTime = (time - frames[frameIndex].timestamp) / (frames[frameIndex + 1].timestamp - frames[frameIndex].timestamp);

                    // setting expression between the current frame and the one that follows
                    blendshapeAnimator.SetFExpression(frames[frameIndex], frames[frameIndex + 1], frameTime);


                }
                // case for the last frame
                else if (frameIndex == frames.Count - 1)
                {
                    // calculating the time passed between frames
                    frameTime = (time - frames[frameIndex].timestamp) / (frames[frameIndex].timestamp - frames[frameIndex - 1].timestamp);

                    // instead of 2 different frames we prolong the final one
                    blendshapeAnimator.SetFExpression(frames[frameIndex], frames[frameIndex], frameTime);

                    // reset values after the video ends
                    play = false;
                    Instance.SetEyeAnimsEnabled(true);
                    frameIndex = 0;
                    time = 0f;
                }

                if (time > frames[frameIndex].timestamp)
                {
                    

                    frameIndex++;
                }



            }

            // time is unstoppable
            time += Time.deltaTime;

            //bsIndex = smRenderers[1].sharedMesh.GetBlendShapeIndex("Mouth_Smile_L");
            //Debug.Log("frame " + frames[frameIndex].frame + " | time " + time + " | timestamp " + frames[frameIndex].timestamp + " | AU " + frames[frameIndex].AU12_r + " | BS " + smRenderers[1].GetBlendShapeWeight(bsIndex));



        }
    }


}
